{
    "data" : {
        "orderConstant" : {
            "modalTitle" : "Константный — O(1)",
            "modalBody" : "Константный — O(1)"
        },
        "orderLinear" : {
            "modalTitle" : "Линейный — O(n)",
            "modalBody" : "Такой сложностью обладает, например, алгоритм поиска наибольшего элемента в не отсортированном массиве. Нам придётся пройтись по всем n элементам массива, чтобы понять, какой из них максимальный."
        },
        "orderLogarithmic" : {
            "modalTitle" : "Логарифмический – O(log n)",
            "modalBody" : "Простейший пример — бинарный поиск. Если массив отсортирован, мы можем проверить, есть ли в нём какое-то конкретное значение, методом деления пополам. Проверим средний элемент, если он больше искомого, то отбросим вторую половину массива — там его точно нет. Если же меньше, то наоборот — отбросим начальную половину. И так будем продолжать делить пополам, в итоге проверим log n элементов."
        },
        "orderLinearLogarithmic" : {
            "modalTitle" : "Линеарифметический — O(n·log n)",
            "modalBody" : "Простейший пример — сортировка слиянием. Эта сортировка — хороший пример использования принципа «разделяй и властвуй». Сначала задача разбивается на несколько подзадач меньшего размера. Затем эти задачи решаются с помощью рекурсивного вызова или непосредственно, если их размер достаточно мал. Наконец, их решения комбинируются, и получается решение исходной задачи."
        }
    }
}
